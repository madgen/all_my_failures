#!/usr/bin/env ruby
# frozen_string_literal: true

require 'all_my_failures'
require 'all_my_failures/session'

require 'optparse'
require 'find'

session_options = {}
program_options = {}

option_parser = OptionParser.new do |opts|
  opts.banner = "usage: #{AllMyFailures::PROGRAM_NAME} <input_file> <command>"
  opts.separator ''
  opts.separator 'Specific options:'

  opts.on('-r',
          '--regexp REGEXP',
          Regexp,
          'Regular exp. to filter files instead of giving a file list') do |r|
    program_options[:file_regexp] = r
  end

  opts.on('-n',
          '--threads THREAD_COUNT',
          Integer,
          'Number of cores used (default: all)') do |n|
    session_options[:n_of_threads] = n
  end

  opts.on('-t',
          '--timeout SECS',
          Integer,
          'Timeout threshold (default: 60s)') do |t|
    session_options[:timeout] = t
  end

  opts.on('-o', '--output FILE', String, 'File to output failing files') do |f|
    program_options[:failure_output] = f
  end

  opts.on('k', '--keep FILE', String, 'File to keep successful outputs') do |f|
    program_options[:success_output] = f
  end

  opts.on('-s', '--suppress', 'Suppress failures at the end of run') do
    session_options[:suppress_failure] = true
  end

  opts.on('-h', '--help', 'Display this message') do
    puts opts
    exit
  end
end

option_parser.parse!(ARGV)

unless (program_options[:file_regexp] && [1, 2].include?(ARGV.size)) ||
       ARGV.size == 2
  STDERR.puts option_parser.banner
  exit 1
end

INPUT_FILES =
  if program_options[:file_regexp]
    ARGV.unshift Dir.pwd if ARGV.size == 1

    input_files = []
    Find.find(ARGV[0]) do |path|
      # Ignore the GIT directory.
      Find.prune if File.directory?(path) && path == '.git'

      input_files << path if path =~ program_options[:file_regexp]
    end

    input_files.freeze
  else
    IO.readlines(ARGV[0]).map(&:chomp).freeze
  end
program_options.delete(:file_regexp)

COMMAND = ARGV[1]

session = Session.new INPUT_FILES, COMMAND, session_options

AllMyFailures.run session, program_options
